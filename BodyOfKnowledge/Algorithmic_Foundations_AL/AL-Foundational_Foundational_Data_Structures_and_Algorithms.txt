Pages:88-90

HOURS
	CS Core = 11
	KA Core = 6

AL-Foundational: Foundational Data Structures and Algorithms
CS Core: (See also: SDF-Data-Structures, SDF-Algorithms)
1. Abstract Data Type (ADT) and operations on an ADT (See also: FPL-Types)
a. Dictionary operations (insert, delete, find)
2. Arrays
a. Numeric vs non-numeric, character strings
b. Single (vector) vs multidimensional (matrix)
3. Records/Structs/Tuples and Objects (See also: FPL-OOP)
4. Linked lists (for historical reasons)
a. Single vs Double and Linear vs Circular
5. Stacks
6. Queues and deques
a. Heap-based priority queue
7. Hash tables/maps
a. Collision resolution and complexity (e.g., probing, chaining, rehash)
8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, and [un]weighted)
(See also: MSF-Discrete)
a. Graph representation: adjacency list vs matrix
9. Trees (See also: MSF-Discrete)
a. Binary, n-ary, and search trees
b. Balanced (e.g., AVL, Red-Black, Heap)
10. Sets (See also: MSF-Discrete)
11. Search algorithms
a. O(n) complexity (e.g., linear/sequential array/list search)
b. O(log2 n) complexity (e.g., binary search)
c. O(logb n) complexity (e.g., uninformed depth/breadth-first tree search)
12. Sorting algorithms (e.g., stable, unstable)
a. O(n2) complexity (e.g., insertion, selection),
b. O(n log n) complexity (e.g., quicksort, merge, timsort)
13. Graph algorithms
a. Shortest path (e.g., Dijkstra’s, Floyd’s)
b. Minimal spanning tree (e.g., Prim’s, Kruskal’s)
KA Core:
14. Sorting algorithms
a. O(n log n) complexity heapsort
b. Pseudo O(n) complexity (e.g., bucket, counting, radix)
15. Graph algorithms
a. Transitive closure (e.g., Warshall’s)
b. Topological sort
16. Matching
a. Efficient string matching (e.g., Boyer-Moore, Knuth-Morris-Pratt)
b. Longest common subsequence matching
c. Regular expression matching
Non-core:
17. Cryptography algorithms (e.g., SHA-256) (See also: SEC-Crypto)
18. Parallel algorithms (See also: PDC-Algorithms, FPL-Parallel)
19. Consensus algorithms (e.g., Blockchain) (See also: SEC-Crypto)
a. Proof of work vs proof of stake (See also: SEP-Sustainability)
20. Quantum computing algorithms (See also: AL-Models, AR-Quantum)
a. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon)
b. Superpolynomial speed-up via QFT (e.g., Shor’s)
c. Polynomial speed-up via amplitude amplification (e.g., Grover’s)
21. Fast-Fourier Transform (FFT) algorithm
22. Differential evolution algorithm
Illustrative Learning Outcomes:
CS Core:
1. For each ADT/Data-Structure in this unit
a. Explain its definition, properties, representation(s), and associated ADT operations.
b. Explain step-by-step how the ADT operations associated with the data structure transform it.
2. For each algorithm in this unit explain step-by-step how the algorithm operates.
3. For each algorithmic approach (e.g., sorting) in this unit apply a prototypical example of the
approach (e.g., merge sort).
90
4. Given requirements for a problem, develop multiple solutions using various data structures and
algorithms. Subsequently, evaluate the suitability, strengths, and weaknesses selecting an
approach that best satisfies the requirements.
5. Explain how collision avoidance and collision resolution is handled in hash tables.
6. Explain factors beyond computational efficiency that influence the choice of algorithms, such as
programming time, maintainability, and the use of application-specific patterns in the input data.
7. Explain the heap property and the use of heaps as an implementation of a priority queue.
KA Core:
8. For each of the algorithms and algorithmic approaches in the KA Core topics:
a. Explain a prototypical example of the algorithm, and
b. Explain step-by-step how the algorithm operates.
Non-core:
9. An appreciation of quantum computation and its application to certain problems.