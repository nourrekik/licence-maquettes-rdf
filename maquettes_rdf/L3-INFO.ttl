@prefix ns1: <http://example.org/course/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ns1:X31A060 rdfs:label "Anglais pour la communication scientifique (info)" ;
    ns1:content """1. Développement du vocabulaire scientifique général
2. Développement du vocabulaire scientifique de spécialité
3. Analyse de textes scientifiques
4. Développement de la capacité à adapter son discours à différentes situations de communication scientifique
4. Analyse de documents audio ou vidéo
5. Pratique de l’oral en contexte
6. Sensibilisation au système phonologique de l’anglais pour améliorer la prise de parole des étudiant-e-s"""^^xsd:string ;
    ns1:hours "17.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """À l’issue de cet enseignement, l’étudiant-e sera capable de :
1. répondre à des questions de compréhension sur un texte rédigé en anglais universitaire, que ce soit dans son domaine de spécialité ou dans un autre domaine, dans un esprit similaire à ce qui est proposé à l’épreuve de compréhension écrite de la certification IELTS Academic English.
2. présenter à l’oral un texte issu de la presse scientifique générale dans son domaine de spécialité, replacer l’article dans son contexte et expliquer les enjeux de la recherche ou de la thématique abordée dans cet article.
3. présenter son travail dans un anglais clair et phonologiquement approprié, en utilisant des outils de présentation adaptés et en communiquant avec un degré d’aisance et de spontanéité qui rende possible une interaction normale avec un locuteur natif, sans recours excessif aux notes."""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31I010 rdfs:label "Etude des algorithmes" ;
    ns1:content """Analyse de problèmes de décision : présentation des notions de décidabilité, introduction des classes de complexité P, NP et Pspace. Présentation la Karp-réduction et de problèmes NP-Dur et NP-Complets.
Vérification de programme
• Vérification dynamiques : aléatoire ; fonctionnelle ; structurelle
• Vérification statique : informelle ; formelle (Hoare et Dijkstra) : correction, terminaison. Preuve et analyse en complexité temporelle de programmes itératifs et récursifs"""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue du module, l'étudiant sera initié à
- Savoir choisir choisir des techniques de réduction adaptées aux propriétés à préserver
- Savoir classer des problèmes de décision
- Savoir choisir les types vérifications à réaliser en fonction des programmes Il saura appliquer les concepts suivants:
- Être capable d'écrire formellement des réductions, simples, de NP-complétude
- Savoir choisir des propriétés à vérifier pour prouver un algorithme et pour établir sa complexité temporelle
- Savoir écrire, pour des algorithmes simples, des preuves de correction et des preuves de complexité temporelle
- Être capable de travailler en groupe"""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31I020 rdfs:label "Algorithmique et Structures de données 3" ;
    ns1:content """Programme :
Ce module présente les structures de données   arborescentes fondamentales pour la mise en place d’une algorithmique efficace, et fait une introduction à la théorie des graphes. Les compétences acquises se situent donc au niveau de la représentation de données, de leur analyse et de la mise en place d’algorithmes.
Contenu :
Structures de données arborescentes
o    monodimensionnelles : arbres binaires, arbres AVL, classes-union etc.
o    multidimensionnelles : arbres quadtratiques (quadtrees), arbres k-d etc.
o    analyse comparative, efficacité, limites Algorithmes gloutons
o    principes, avantages et limites
o    applications Algorithmique des graphes
o    structure, propriétés, implémentations
o    pondération, arbres recouvrants
o    analyse temporelle et spatiale"""^^xsd:string ;
    ns1:ects "3.0"^^xsd:float ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l’issue de cette UE, l’étudiant saura :
•
définir une structure de données arborescente ou de type graphe en décrivant ses propriétés (Connaissance) ;
•
concevoir des structures de données arborescentes ou de type graphe au moyen de structures linéaires et associatives (Analyse) ;
•
implémenter des algorithmes de parcours et de manipulation d’arbres (Application) ;
•
résoudre des problèmes simples de la théorie des graphes en employant une approche gloutonne lorsqu’elle est appropriée (Analyse) ;
•
calculer la complexité d'un algorithme en fonction des structures de données choisies (Synthèse) ;
• choisir la structure de données la plus efficace pour la résolution d'un problème (Synthèse) ;"""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31I030 rdfs:label "Langage et automates" ;
    ns1:content """Automates finis et analyse lexicale : langages et opérations, langages rationnels, automates finis, automates finis déterministes. Équivalence des expressions rationnelles et des automates finis. Analyse lexicale, expressions rationnelles étendues.
Grammaires formelles : classification, grammaires hors contexte, arbre de dérivation, ambiguïté, formes normales. Automates à pile et transducteurs finis.
Analyse syntaxique : analyse ascendante et descendante avec rebroussement, méthodes tabulaires, analyse sans rebroussement : grammaires de précédence, grammaires LL(k).
Travaux Pratiques : Lex et Yacc"""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue du module, l'étudiant sera initié à
- Savoir utiliser les logiciels flex et bison Il maîtrisera les concepts:
- Savoir raisonner sur les langages formels
- Savoir écrire une expression rationnelle
- Savoir résoudre un système d'équations linéaires droites
- Savoir si un mot correspond à une expression rationnelle
- Savoir déterminer la classe d'une grammaire formelle dans la hiérarchie de Chomsky
- Savoir si un mot est engendré par une grammaire rationnelle, algébrique ou contextuelle
- Connaître les propriétés d'un automate fini
- Savoir rendre déterministe un automate fini
- Savoir minimaliser le nombre d'états d'un automate fini déterministe
- Savoir si un mot est accepté par un automate fini
- Savoir transformer une grammaire rationnelle en une expression rationnelle ou en un automate fini et inversement"""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31I040 rdfs:label "Réseaux et Télécoms" ;
    ns1:content """Programme - Contenu de l'UE : Internet : comment ça marche.
• Introduction : les chiffres de l'Internet, histoire et perspectives.
• Les protocoles applicatifs (http, smtp, dns, ...)
• Le problème du transport fiable de bout en bout. TCP.
• Le problème du contrôle de flux et congestion. TCP.
• Le problème de l'adressage et du routage. IP.
• Le problème du partage du canal de transmission.
• Les codes détecteurs et correcteurs d'erreurs.
• Les réseaux mobile et sans fil.
• Sécurité informatique."""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de ce cours, l'étudiant doit:
• Acquérir une vue globale des mécanismes mis en jeu dans l’Internet (« Internet : comment ça marche ? » ) ;
• Comprendre les mécanismes de base des protocoles de l’Internet (http, tcp, ip, arp);
• Connaître les défis techniques et sociétaux liés aux déploiements des réseaux;"""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31I050 rdfs:label "Architecture des ordinateurs" ;
    ns1:content """Programme   :
* Représentation de l'information: codage des caractères, entiers, réels, instructions.
* Métriques de performances
* Circuits logiques combinatoires et séquentiels
* Le processeur: présentation du jeu d'instruction d'une machine RISC et de son pipeline (aléas de données et de
contrôle).
* Les mémoires: communication par bus, principe de localité, cache, virtualisation
* Multiprocesseurs, multicœurs et GPU [optionnel, en fonction du temps disponible]
Les travaux pratiques sont en C/C++ et en assembleur MIPS. Une partie importante du travail est laissée à l'initiative des étudiants en dehors des cours programmés."""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de ce cours, l'étudiant doit:
• connaître la représentation des informations en binaire dans les machines (entiers, réels au format IEEE 754, caractères et chaînes de caractères, instructions);
• savoir manipuler les nombres entiers et réels dans différentes bases et passer d'une base à l'autre;
• savoir effectuer des opérations en binaire sur les entiers et les réels;
• savoir comparer des systèmes informatiques en fonction des indicateurs pertinents;
• savoir analyser et synthétiser des circuits combinatoires et séquentiels et connaître l'implémentation des éléments logiques de base (mux/demux,   registres, ...);
• connaître les principes de la programmation dans un langage d'assemblage et savoir traduire les appels de fonctions et de procédures en respectant les conventions dictées par l'environnement;
• savoir mettre en oeuvre un processeur monocycle simple en définissant les chemins de données de son jeu d'instructions;
• connaître les principes sous-tendant les processeurs multicycles et les architectures pipelinées
• connaître la notion de cache mémoire et ses différentes implémentations, et en connaître les impacts sur les algorithmes."""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X31T060 rdfs:label "Ouverture professionnelle - Informatique" ;
    ns1:content """L’enseignement de cette UE est réparti comme suit :
1. Des séances de TD permettant de travailler en mode projet sur la recherche de stage et la communication orale : méthodologie, CV, lettre de motivation, utilisation du réseau professionnel LinkedIn, de l’outil CareerCenter et certains réseaux pour les scientifiques tels que Researchgate.
2. Des séances de TD permettant de vivre et de comprendre le fonctionnement d’une structure professionnelle. Ces séances permettront également à l’étudiant de réfléchir à son positionnement en tant que stagiaire dans un environnement professionnel.
2h40 : TD 1 : Méthodologie de recherche de stage : réflexion sur les objectifs pour ce stage, construction des différentes étapes de la recherche, décryptage d’une offre, mise à jour des compétences, du CV et personnalisation de la lettre de motivation.
1h20 : TD 2 : Outils de recherche de stage : CareerCenter, LinkedIn : présentation et temps pour remplir son profil.
2h40 : TD 3 : Communication orale : les fondamentaux de la communication, le non verbal, comment construire une présentation professionnelle pour se présenter à un recruteur (pitch), adopter une posture professionnelle.
4h00 : TD 4 : Simulations d’entretiens en sous-groupes autonomes et présentation du pitch
(évaluation).
4h00 : TD 5 : Les différentes structures et organisations possibles dans le monde du travail / Droits et devoirs du stagiaire.
1h20 : TD 6 : L’après licence : en sous-groupes, argumentation de ses perspectives post-licence.
Enseignement en distanciel
Avant certaines séances de TD (TD1, TD2, TD3, TD5), un enseignement en distanciel sera proposé aux étudiants :
Outils de mise en réflexion sur les objectifs du stage recherchés ;
Documents à lire de façon à pouvoir les mettre en œuvre autour de la méthodologie de recherche de stage ;
Power points à visionner sur les outils Career Center et LinkedIn ;
Vidéos à visionner sur les différentes organisations et types de métiers exercés dans une organisation ;
Quizz à réaliser sur les droits et devoirs du stagiaire."""^^xsd:string ;
    ns1:hours "17.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """Projet Professionnel : recherche de stage et poursuite d’études A l’issue de cette UE, l’étudiant saura :
- optimiser sa méthodologie de recherche de stage
- décrypter une offre de stage
- réactualiser ses compétences et remettre son CV à jour
- le fonctionnement des réseaux sociaux professionnels et créer son profil
- utiliser les services de l’université pour ses recherches de stage ou d’emploi. Découverte et connaissance du monde du travail
A l’issue de cette UE, l’étudiant aura :
- travaillé en équipe sur les différentes structures et organisations possibles rencontrées dans le monde du travail (statut juridique, services, organigramme, taille, valeurs, partenaires..)
- étudié une structure en particulier, en lien avec son projet professionnel
- par le biais d’un jeu de rôle, pris conscience du rôle des différents services (RH, marketing, commercial,…) d’une structure dans le développement et le déploiement d’un projet
- connaissance de ses droits et devoirs en tant que stagiaire et aura travaillé sur sa manière de s’intégrer et de s’adapter dans un nouveau milieu professionnel
- connaissance de ce qu’est l’entreprenariat et des dispositifs en lien à l’université Communication
Au terme de l’UE ‘Ouverture Professionnelle’, l’étudiant connaitra :
- les principes fondamentaux de la communication systémique et interpersonnelle, utiles pour communiquer en milieu professionnel
- la manière d'exprimer un message clair, précis, bienveillant, à la reformulation et à l’expression d’un feedback"""^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:X32A060 rdfs:label "Anglais Professionnel Informatique" ;
    ns1:content """1. Développement du vocabulaire utilisé en anglais professionnel (vocabulaire susceptible d’être utilisé dans les tests TOEIC)
2. Discussion des spécificités des CV aux États-Unis et en Grande-Bretagne
3. Contenu d’une lettre de motivation
4. Déroulement d’un entretien d’embauche
5. Vocabulaire utilisé lors des communications téléphoniques
6. Pratique de l’oral en contexte
7. Sensibilisation au système phonologique de l’anglais pour améliorer la prise de parole des étudiant-e-s"""^^xsd:string ;
    ns1:hours "17.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """À l’issue de cet enseignement, l’étudiant-e sera capable de :
1. réaliser un rapport dans le cadre d’un projet de groupe impliquant une mise en situation dans un contexte professionnel simulé
2. rédiger un texte dans un anglais clair et grammaticalement approprié au contexte, dans le cadre d’un projet de groupe
3. faire une présentation orale s’appuyant sur le travail de groupe préparé dans le rapport écrit, en s’exprimant dans un anglais clair et phonologiquement approprié et en communiquant avec un  degré d’aisance et de spontanéité qui rende possible une interaction normale avec un locuteur natif, sans recours excessif aux notes
4. utiliser des outils de présentation adaptés à la situation de communication
5. répondre à des questions de compréhension sur des documents audio authentiques"""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32I010 rdfs:label "Informatique Fondamentale 2" ;
    ns1:content """Cadres généraux de calcul
Systèmes de transitions et automates formels : automates et transducteurs finis, automates à piles et à compteurs, machines de Turing.
Conception formelle relationnelle des automates et des calculs. Machines d'Eilenberg. Simulation des automates.
Calculs récursifs. Les principaux cas : langages hors contexte, sémantique des programmes logiques définis. Opérateurs continus sur les domaines partiellement ordonnés. Point fixe. Calculabilité et décidabilité
Énumérations de Godel. Fonctions récursives.
Problèmes non décidables. Réductions entre les problèmes. Calculs symboliques
Lambda calcul. Sémantique opérationnelle par réduction de termes. Propriété de Church-Rosser. Sémantique fonctionnelle. Liens avec les langages fonctionnels.
Systèmes équationnels. Sémantiques algébrique et opérationnelle. Problème de résolution. Systèmes de réécriture de termes. Problèmes de terminaison et de confluence. Ordres de calculabilité."""^^xsd:string ;
    ns1:ects "2.0"^^xsd:float ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de ce module, l'étudiant saura:
- connaître les propriétés des langages algébriques
- concevoir un automate à pile à partir d'une grammaire algébrique
- savoir démontrer qu'un langage n'est pas algébrique à l'aide du lemme d'itération
- savoir démontrer qu'un ensemble est dénombrable / indénombrable
- concevoir une machine de Turing qui accepte / décide un langage
- distinguer un problème décidable d'un problème indécidable
- comprendre la résolution de problèmes par réduction
- comprendre la construction des fonctions et prédicats récursifs primitifs
- savoir faire une preuve par induction
- savoir construire des objets inductivement
- savoir construire des termes, les manipuler, et les transformer
- comprendre le mécanisme d'unification
- savoir ordonner des termes"""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32I020 rdfs:label "Programmation fonctionnelle" ;
    ns1:content """Programme :
•
Les paradigmes de programmation déjà étudiés et celui de la programmation fonctionnelle
•
Programmation fonctionnelle pure
•
Expression, valeur et type
•
Valeur fonctionnelle (en bref : fonction)
•
Fonction d'ordre supérieur
•
Application d'une fonction (y compris application partielle)
•
Évaluation stricte, évaluation paresseuse
•
Inférence de type
• Polymorphisme
•
Définition (ou liaison) : locale ou globale
•
Fonction anonyme
•
Définition inductive d'ensembles
•
Preuve par récurrence, preuve par induction structurelle
•
Définition récursive de fonctions (y compris mutuelle)
•
Définition de types (dont définition récursive, y compris mutuelle)
•
Programmation par filtrage de motifs
•
Preuve de terminaison et de correction d'un programme fonctionnel
•
Récursivité terminale
•
Effet de bord
•
Programmer en combinant paradigmes fonctionnel et impératif
• Apprentissage d'un langage fonctionnel avec inférence de types, permettant de programmer par filtrage et de combiner ces paradigmes"""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l’issue de cette UE, l’étudiant saura :
•
implémenter des algorithmes, y compris de traitement de structures de données linéaires, associatives et arborescentes, selon le paradigme fonctionnel (Application) ;
•
concevoir et employer des fonctions d’ordre supérieure (Application) ;
•
employer la programmation par filtrage de motifs pour les traitements symboliques (Application) ;
• expliquer et savoir simuler le mécanisme d’inférence de type (Compréhension) ;"""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32I030 rdfs:label "Recherche opérationnelle" ;
    ns1:content """Ce cours d'introduction à la Recherche Opérationnelle (RO) est composé de deux parties :
•
La partie dite « fondamentale » introduit les notions minimales que tout informaticien se doit de connaître : Comprendre un problème posé, le modéliser (c'est-à-dire en donner une description non- ambigüe), connaître les propriétés de ce modèle pour ensuite le résoudre à l'aide d'un solveur approprié, et enfin interpréter la solution numérique obtenue en termes concrets. Le formalisme choisi pour cette partie est la Programmation Linéaire.
•
La partie dite de « découverte » complète la partie fondamentale en introduisant d'autres formalismes de modélisation, d'autres problématiques, et d'autres méthodes de résolution. Cette seconde partie permet en particulier d'avoir une meilleure idée de ce qu'est la Recherche Opérationnelle.
•
Contenu fondamental :
-
Introduction à la modélisation par la programmation linéaire
-
Utilisation de variables continues, entières et binaires
-
Modélisation avancée : linéarisation de modèles en utilisant des variables binaires
-
Propriétés géométriques, caractérisation des solutions optimales, et résolution graphique de programmes linéaires
-
Résolution de programmes linéaires par l'algorithme du simplexe
-
Interprétation des solutions et analyse de sensibilité
-
Utilisation de langages de modélisation et de solveurs de programmation linéaires
-
Instanciation et application sur des études de cas (industrie minière, transports et logistique, ordonnancement, gestion de l'énergie, santé, planification de la production, économie et finance, télécommunication, emploi du temps...)
•
Contenu de découverte :
-
Introduction à la modélisation de problèmes d'optimisation par la théorie des graphes
-
Introduction à l'ordonnancement simple
-
Introduction à la programmation dynamique
-
Introduction à l'optimisation multiobjectif
-
Introduction aux métaheuristiques"""^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de cette UE, l'étudiant devra
- Etre capable de modéliser des programmes linéaires (variables continues et entières), et de reconnaître les principales structures de problème (structure de recette, structure de couverture, structure de mélange, structure multi-période) (A - M)
- Etre capable d'utiliser des variables binaires pour modéliser des problèmes d'optimisation combinatoire, et de reconnaître certaines structures combinatoires (A - M)
- Etre capable d'utiliser les principales astuces de modélisation basées sur l'utilisation de variables binaires (A - M)
- Connaître les propriétés géométriques des programmes linéaires en variables continues, caractérisation des solutions optimales (M)
- Etre capable de résoudre graphiquement un programme linéaire (M)
- Connaître les notions de base, solution de base, et coût réduit en programmation linéaire en variables continues (M)
- Etre capable d'utiliser l'algorithme du simplexe pour la résolution de programme linéaires en variables continues (A)
- Connaître les différences entre le cas continu et le cas discret en programmation linéaire (I)
- Introduction des principales méthodes de résolution pour la programmation linéaire en variables entières, intérêt pour d'autres formalismes de modélisation dans ce contexte (I)
- Connaître les notions de coût dual associé à une contrainte, d'intervalle de sensibilité d'un coefficient de la fonction objectif ou d'un second membre d'une contrainte, être capable d'interpréter leur signification (I)
- Etre capable de déterminer l'intervalle de sensibilité d'un coefficient de la fonction objectif ou d'un second membre d'une contrainte (A)
- Etre capable de modéliser un problème d'ordonnancement simple par un graphe potentiel-tâche (A-M)
- Connaître les notions de calendrier au plus tôt, calendrier au plus tard pour un ensemble de tâche, et la notion de marge d'une tâche dans le contexte d'un problème d'ordonnancement simple (M)
- Etre capable de déterminer un calendrier au plus tôt, un calendrier au plus tard et les marges des tâches, dans le contexte d'un problème d'ordonnancement simple (A)
- Introduction à la problématique de l'optimisation multi-objectif : connaissance de la notion de solution efficace, limite de l'utilisation de la somme pondérée (I)
- Utilisation d'un langage de modélisation algébrique : comprendre la différence entre un modèle explicite et un modèle implicite (I)
- Utilisation d'un langage de modélisation algébrique : être capable d'écrire un modèle implicite (A)
- Utilisation d'un langage de modélisation algébrique : comprendre l'utilisation d'une structure de matrice creuse pour décrire des contraintes (I)
- Utilisation d'un langage de modélisation algébrique : être capable d'utiliser une structure de matrice creuse pour décrire des contraintes (A)
- Utilisation d'un langage de modélisation algébrique : être capable de détermine si le choix d'une matrice creuse est pertinent ou pas pour décrire des contraintes (A)
- Utilisation d'un solveur MIP : comprendre l'utilisation d'un solveur MIP en tant que bibliothèque de fonction et être capable de l'utiliser pour résoudre un unique problème de programmation linéaire en variables mixtes (A)
- Utilisation d'un solveur MIP : être capable d'implémenter un algorithme donné, en faisant des appels successifs à un solveur MIP pour résoudre un problème de programmation linéaire en variables mixtes (A)"""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32I040 rdfs:label "Bases de données 2" ;
    ns1:content """Introduction aux systèmes de Gestion de Bases de données (architecture, évaluation et optimisation de requêtes, gestion des transactions et contrôle de concurrence, sensibilisation à la gestion des gros volumes de données)
Extension procédurale de SQL (PL/SQL) , BD actives (Déclencheurs) Interrogation d'une base avec JDBC
Modèle objet-relationnel"""^^xsd:string ;
    ns1:ects "2.0"^^xsd:float ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de ce module, l'étudiant devra:
• Comprendre les dépendances fonctionnelles
• Comprendre la normalisation des relations d’une base de données (formes normales) et l’impact opérationnel d’une normalisation.
• Être capable d’utiliser des algorithmes de décomposition de relations pour normaliser une base de données
• Avoir une bonne pratique d’un langage procédurale lié à une base de données, par exemple PL/SQL ou PL/pgSQL
• Savoir concevoir et appliquer les déclencheurs
• Savoir déterminer des contraintes d’intégrité
• Savoir appliquer un contrôle d’accès basique à une base de données
• Comprendre la notion de vue
• Connaître la structuration physique des données
• Comprendre la notion de transaction
• Comprendre la notion d’ordonnancement sérialisable
• Comprendre la technique de contrôle de concurrence par verrouillage
• Comprendre les fonctions d’un optimiseur de requêtes
• Comprendre un plan d’exécution d’une requête
• Connaître les structures accélératrices d’accès aux données (indexes)"""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32I050 rdfs:label "Construction et évolution de logiciels" ;
    ns1:content "L'objectif de ce module est de maîtriser les étapes de développement logiciel, qu'il s'agisse de sa conception, sa construction, son développement, ses tests, son évolution mais aussi de sa modernisation. Les principes de travail dans une équipe de développement en entreprise. La rédaction de documentation logicielle, la maintenance logicielle, l'analyse de code et la gestion d'exception seront aussi abordés dans ce module."^^xsd:string ;
    ns1:hours "46.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:objective """A l'issue de ce module, l'étudiant devra:
• Comprendre les principaux enjeux de la construction et de l'évolution de logiciels.
• Comprendre les approches de modernisation de logiciels, comme la rétro ingénierie, la réingénierie, le salvaging et la restructuration.
• Comprendre les différentes utilisations d'un gestionnaire de configurations dans un système en production.
• Être capable de réaliser un projet informatique   au sein d'une petite équipe et de le livrer à un client. En ce faisant, il doit démontre sa capacité à travailler en équipe et à livrer un projet correctement.
• Être capable d'appliquer les opérations de restructuration de code appropriées pour résoudre des problèmes de conception.
• Être capable d'appliquer des heuristiques connues de construction et de maintenance pour améliorer un logiciel existant, comme par exemple, éliminer des variables globales, appliquer des conventions de codage et rendre le logiciel testable.
• Être capable de traduire la conception détaillée d'un logiciel en code source. En ce faisant, il doit démontrer sa maîtrise des règles génériques de correspondance entre la conception et le code.
• Savoir organiser et rédiger le documentation utilisateur d'un logiciel dans le but de le rendre utilisable à long terme.
• Être capable d'effectuer des opération de maintenance corrective, perfective, adaptative et préventive.
• Être capable d'utiliser des outils d'analyse de code source pour appréhender un logiciel existant.
• Être capable d'utiliser la gestion d'exception, ainsi que d'autre techniques spécifiques aux langages de programmation pour améliorer la tolérance aux fautes."""^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:X32T060 rdfs:label "Stage" ;
    ns1:hours "0.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:semester "6"^^xsd:int .

ns1:XLG5TU200 rdfs:label "Stage libre" ;
    ns1:hours "0.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:semester "5"^^xsd:int .

ns1:XLG6TU200 rdfs:label "Stage libre" ;
    ns1:hours "0.0"^^xsd:float ;
    ns1:level "Licence"^^xsd:string ;
    ns1:semester "6"^^xsd:int .

